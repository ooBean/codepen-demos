<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sticky Notes</title>
    <style>
        :root {
            --note-hue: 200;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(to right, #ff9a9e, #fecfef);
            overflow: hidden;
        }

        .notes-container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        .note-wrapper {
            position: absolute;
            width: 250px;
            min-height: 150px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
            border-radius: 15px;
            cursor: move;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #333;
            transition: transform 0.2s, box-shadow 0.2s, background 0.3s, opacity 0.3s;
            container-type: inline-size;
            opacity: 0;
            transform: translateY(10px) scale(0.98);
        }

        .note-enter {
            animation: pop 360ms cubic-bezier(.2,.8,.2,1) forwards;
        }

        @keyframes pop {
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @container style(--is-editing: 1) {
            .note-wrapper {
                background: hsla(var(--note-hue, 200), 70%, 80%, 1);
                backdrop-filter: none;
            }
            .note-close {
                opacity: 0;
                pointer-events: none;
            }
        }

        .note-wrapper:hover {
            transform: scale(1.05);
            box-shadow: 0 20px 45px rgba(0,0,0,0.25);
        }

        .note-body {
            padding: 20px;
            box-sizing: border-box;
            height: 100%;
        }

        .note-content {
            min-height: 120px;
            outline: none;
            font-size: 1.1em;
            line-height: 1.5;
            caret-color: #333;
        }

        .note-close {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            font-size: 1.5em;
            color: rgba(0,0,0,0.5);
            transition: color 0.2s, opacity 0.3s;
        }

        .note-close:hover {
            color: rgba(0,0,0,0.8);
        }

        .add-note-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #ff7eb9;
            color: white;
            text-align: center;
            line-height: 60px;
            font-size: 30px;
            cursor: pointer;
            border: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transition: transform 0.2s, background-color 0.2s;
        }

        .add-note-btn:hover {
            transform: scale(1.1);
            background-color: #ff6baf;
        }
    </style>
</head>
<body>
    <div class="notes-container" id="notesContainer"></div>
    <button class="add-note-btn" id="addNoteBtn">+</button>
    <script>
        const notesContainer = document.getElementById('notesContainer');
        const addNoteBtn = document.getElementById('addNoteBtn');
        let notes = new Map();
        let activeNote = null;
        let highestZ = 0;

        // rAF-driven dragging: keep last event and batch updates for smoothness
        let rafPending = false;
        let lastPointerEvent = null;

        function createEl(tag, props = {}) {
            const el = document.createElement(tag);
            Object.assign(el, props);
            if (props.style) Object.assign(el.style, props.style);
            return el;
        }

        function createNote(id, { x, y, content = 'New Note' }) {
            const noteWrapper = createEl('div', {
                className: 'note-wrapper',
                id: `note-${id}`,
                style: {
                    left: `${x}px`,
                    top: `${y}px`,
                    '--note-hue': Math.random() * 360,
                    background: `hsla(var(--note-hue, 200), 70%, 80%, 0.7)`,
                    touchAction: 'none'
                },
                tabIndex: 0,
                role: 'article',
                'aria-label': 'Sticky note'
            });

            const noteBody = createEl('div', { className: 'note-body' });
            const noteContent = createEl('div', {
                className: 'note-content',
                textContent: content,
                contentEditable: true,
                'aria-label': 'Note content'
            });
            const closeBtn = createEl('div', { className: 'note-close', textContent: 'Ã—', title: 'Delete note' });

            noteBody.append(noteContent, closeBtn);
            noteWrapper.appendChild(noteBody);
            notesContainer.appendChild(noteWrapper);

            const noteData = { element: noteWrapper, content, x, y };
            notes.set(id, noteData);
            return noteData;
        }

        function deleteNote(id) {
            const noteData = notes.get(id);
            if (!noteData) return;
            noteData.element.remove();
            notes.delete(id);
            saveNotes();
        }

        function exitEditingState(noteContent) {
            const noteWrapper = noteContent.closest('.note-wrapper');
            noteWrapper.style.removeProperty('--is-editing');
            const id = Number(noteWrapper.id.split('-')[1]);
            const noteData = notes.get(id);
            if (noteData) {
                noteData.content = noteContent.textContent;
                if (noteContent.textContent.trim() === '') {
                    deleteNote(id);
                    return;
                }
                saveNotes();
            }
        }

        // Persist notes to localStorage for demo / portfolio convenience
        function saveNotes() {
            try {
                const data = Array.from(notes.entries()).map(([id, d]) => ({ id, x: d.x, y: d.y, content: d.content }));
                localStorage.setItem('sticky-notes', JSON.stringify(data));
            } catch (e) {
                // ignore localStorage errors
            }
        }

        function loadNotes() {
            try {
                const data = JSON.parse(localStorage.getItem('sticky-notes') || '[]');
                if (data.length > 0) {
                    data.forEach(item => {
                        createNote(item.id, { x: item.x, y: item.y, content: item.content });
                    });
                    // trigger enter animation for loaded notes
                    requestAnimationFrame(() => {
                        document.querySelectorAll('.note-wrapper').forEach(n => n.classList.add('note-enter'));
                    });
                }
                return data.length;
            } catch (e) {
                return 0;
            }
        }

        // Event delegation: focus, blur and click handled at container level
        notesContainer.addEventListener('focusin', (e) => {
            if (e.target.classList.contains('note-content')) {
                e.target.closest('.note-wrapper').style.setProperty('--is-editing', '1');
            }
        });

        notesContainer.addEventListener('focusout', (e) => {
            if (e.target.classList.contains('note-content')) {
                exitEditingState(e.target);
            }
        });

        notesContainer.addEventListener('click', (e) => {
            // delete via delegation
            if (e.target.classList.contains('note-close')) {
                const id = Number(e.target.closest('.note-wrapper').id.split('-')[1]);
                deleteNote(id);
            }
        });

        // Pointer events with rAF batching for smoothness and lower CPU usage
        notesContainer.addEventListener('pointerdown', (e) => {
            const noteWrapper = e.target.closest('.note-wrapper');
            if (!noteWrapper || e.target.classList.contains('note-content') || e.target.classList.contains('note-close')) return;

            highestZ++;
            noteWrapper.style.zIndex = highestZ;
            const id = Number(noteWrapper.id.split('-')[1]);
            activeNote = {
                id,
                element: noteWrapper,
                offsetX: e.clientX - noteWrapper.getBoundingClientRect().left,
                offsetY: e.clientY - noteWrapper.getBoundingClientRect().top,
                isDragging: false
            };
            noteWrapper.setPointerCapture(e.pointerId);
            lastPointerEvent = null;
        });

        notesContainer.addEventListener('pointermove', (e) => {
            if (!activeNote) return;
            activeNote.isDragging = true;
            lastPointerEvent = e;
            if (!rafPending) {
                rafPending = true;
                requestAnimationFrame(processPointerMove);
            }
        });

        function processPointerMove() {
            rafPending = false;
            if (!activeNote || !lastPointerEvent) return;
            const e = lastPointerEvent;
            let x = e.clientX - activeNote.offsetX;
            let y = e.clientY - activeNote.offsetY;
            const maxX = window.innerWidth - activeNote.element.offsetWidth;
            const maxY = window.innerHeight - activeNote.element.offsetHeight;
            x = Math.max(0, Math.min(x, maxX));
            y = Math.max(0, Math.min(y, maxY));
            activeNote.element.style.left = `${x}px`;
            activeNote.element.style.top = `${y}px`;
            // update stored position immediately for persistence
            const data = notes.get(activeNote.id);
            if (data) {
                data.x = x;
                data.y = y;
            }
            lastPointerEvent = null;
        }

        function endPointerInteraction(e) {
            if (!activeNote) return;
            if (activeNote.isDragging) {
                const noteData = notes.get(activeNote.id);
                if (noteData) {
                    noteData.x = parseInt(activeNote.element.style.left) || noteData.x;
                    noteData.y = parseInt(activeNote.element.style.top) || noteData.y;
                }
                saveNotes();
            }
            try { activeNote.element.releasePointerCapture(e.pointerId); } catch (err) {}
            activeNote = null;
            lastPointerEvent = null;
        }

        notesContainer.addEventListener('pointerup', endPointerInteraction);
        notesContainer.addEventListener('pointercancel', endPointerInteraction);

        addNoteBtn.addEventListener('click', () => {
            const x = Math.random() * (window.innerWidth - 270);
            const y = Math.random() * (window.innerHeight - 200);
            const id = Date.now();
            const note = createNote(id, { x, y });
            requestAnimationFrame(() => note.element.classList.add('note-enter'));
            saveNotes();
        });

        // Staggered "popcorn" load animation: create several notes with delays
        function initPopcorn(count = 6, gap = 120) {
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    const x = Math.random() * (window.innerWidth - 270);
                    const y = Math.random() * (window.innerHeight - 200);
                    const id = Date.now() + i;
                    const note = createNote(id, { x, y });
                    note.element.classList.add('note-enter');
                }, i * gap);
            }
        }

        window.addEventListener('load', () => {
            const count = loadNotes();
            if (!count) initPopcorn(6, 120);
        });
    </script>
</body>
</html>